{"meta":{"title":"game development","subtitle":"","description":"","author":"John Doe","url":"http://example.com","root":"/"},"pages":[{"title":"[404]","date":"2022-11-27T05:59:15.129Z","updated":"2022-11-27T05:59:15.129Z","comments":true,"path":"404.html","permalink":"http://example.com/404.html","excerpt":"","text":""},{"title":"","date":"2022-11-27T06:06:11.442Z","updated":"2022-11-27T06:06:11.442Z","comments":true,"path":"about/index.html","permalink":"http://example.com/about/index.html","excerpt":"","text":"​—title:自我介绍标题layout:about​—literwave来源于我叫小波"}],"posts":[{"title":"lua-mix","slug":"lua-mix","date":"2023-07-29T04:39:39.000Z","updated":"2023-07-29T13:03:51.459Z","comments":true,"path":"2023/07/29/lua-mix/","link":"","permalink":"http://example.com/2023/07/29/lua-mix/","excerpt":"","text":"前言​ 这是一篇关于lua源码分析的杂谈，里面混入各种知识 正文 static的作用，一个局部变量的创建是在栈区，当出栈的时候，局部变量就销毁了，而使用static 关键字修饰，可以改变变量的生命周期，也就是不会销毁，但是不会改变作用域。使用static修饰全局变量的时候，会使它的作用域变小，也就是外部不可以链接 remalloc函数支持缩容 解析luaL_openlibs 12345678910111213141516171819202122232425262728293031extern void luaL_openlibs (lua_State *L) &#123; const luaL_Reg *lib; /* &quot;require&quot; functions from &#x27;loadedlibs&#x27; and set results to global table */ for (lib = loadedlibs; lib-&gt;func; lib++) &#123; luaL_requiref(L, lib-&gt;name, lib-&gt;func, 1); lua_pop(L, 1); /* remove lib */ &#125;&#125;// modname = _G// openf = luaopen_baseextern void luaL_requiref (lua_State *L, const char *modname, lua_CFunction openf, int glb) &#123; luaL_getsubtable(L, LUA_REGISTRYINDEX, LUA_LOADED_TABLE); lua_getfield(L, -1, modname); /* LOADED[modname] */ if (!lua_toboolean(L, -1)) &#123; /* package not already loaded? */ lua_pop(L, 1); /* remove field */ lua_pushcfunction(L, openf); lua_pushstring(L, modname); /* argument to open function */ lua_call(L, 1, 1); /* call &#x27;openf&#x27; to open module */ lua_pushvalue(L, -1); /* make copy of module (call result) */ lua_setfield(L, -3, modname); /* LOADED[modname] = module */ &#125; lua_remove(L, -2); /* remove LOADED table */ if (glb) &#123; lua_pushvalue(L, -1); /* copy of module */ lua_setglobal(L, modname); /* _G[modname] = module */ &#125;&#125;lua_setfield(L, -2, &quot;_G&quot;); 其实会把 最后又会把l-&gt;top -2,其实又回到起点 函数lua_call其实就是new了一个ci，如果想得到一个返回值其实就是ci-&gt;top + wanted就是函数执行的返回值了 lua数据类型，lua的tvalue就包括所有类型 1234567891011/*** Union of all Lua values*/typedef union Value &#123; GCObject *gc; /* collectable objects */ void *p; /* light userdata */ int b; /* booleans */ lua_CFunction f; /* light C functions */ lua_Integer i; /* integer numbers */ lua_Number n; /* float numbers */&#125; Value; gcobject类型如下，这是需要垃圾回收的类型 12345struct GCObject &#123; GCObject *next; lu_byte tt; lu_byte marked;&#125;;","categories":[],"tags":[]},{"title":"lua-debug-vscode","slug":"lua-debug-vscode","date":"2023-07-16T02:41:06.000Z","updated":"2023-07-16T07:02:16.588Z","comments":true,"path":"2023/07/16/lua-debug-vscode/","link":"","permalink":"http://example.com/2023/07/16/lua-debug-vscode/","excerpt":"","text":"前言 搜了许多资料，觉得vscode调式c程序的教程有点杂，所以写下这篇博客，使用vscode调用lua源码，版本是lua5.3.6,下载地址为http://www.lua.org/versions.html 正文 vscode的插件准备（有安装code runner的需要禁止用） 准备一个vscode工程目录如下： 把lua-5.3.6的源文件复制一份到include文件夹和src，然后使用del *h或del *c删除对应不需要的文件夹。如图： 然后需要注释掉lua.c源码的int main和luac.c源码的int main的入口 vscode调式c配置，首先使用shift+ctrl+p,如下图所示，会生成c_cpp_properties.json文件，如图 在&#96;&#96;文件里添加这一条规则，这样头文件不会是红线了 接下来配置task.json task.json的配置如下 1234567891011121314151617181920212223242526272829&#123; &quot;version&quot;: &quot;2.0.0&quot;, &quot;tasks&quot;: [ &#123; &quot;type&quot;: &quot;cppbuild&quot;, &quot;label&quot;: &quot;C/C++: gcc.exe build active file&quot;, &quot;command&quot;: &quot;gcc&quot;, &quot;args&quot;: [ &quot;-g&quot;, &quot;$&#123;workspaceFolder&#125;\\\\src\\\\*.c&quot;, // &quot;$&#123;fileDirname&#125;\\\\*.c&quot;, &quot;-o&quot;, &quot;$&#123;fileDirname&#125;\\\\$&#123;fileBasenameNoExtension&#125;.exe&quot;, &quot;-I&quot;, &quot;$&#123;workspaceFolder&#125;\\\\include&quot;, ], &quot;options&quot;: &#123; &quot;cwd&quot;: &quot;$&#123;fileDirname&#125;&quot; &#125;, &quot;group&quot;: &#123; &quot;kind&quot;: &quot;build&quot;, &quot;isDefault&quot;: true &#125;, &quot;detail&quot;: &quot;compiler: D:\\\\environment\\\\MinGw64\\\\bin\\\\gcc.exe&quot; &#125; ]&#125; c_cpp_properties.json配置如下 123456789101112131415161718192021&#123; &quot;configurations&quot;: [ &#123; &quot;name&quot;: &quot;Win32&quot;, &quot;includePath&quot;: [ &quot;$&#123;workspaceFolder&#125;/**&quot;, &quot;$&#123;workspaceFolder&#125;/include&quot; ], &quot;defines&quot;: [ &quot;_DEBUG&quot;, &quot;UNICODE&quot;, &quot;_UNICODE&quot; ], &quot;compilerPath&quot;: &quot;D:/environment/MinGw64/bin/gcc.exe&quot;, &quot;cStandard&quot;: &quot;c11&quot;, &quot;cppStandard&quot;: &quot;c++11&quot;, &quot;intelliSenseMode&quot;: &quot;windows-gcc-x86&quot; &#125; ], &quot;version&quot;: 4&#125; 创建如下文件在src里，testlua.c, testlua.lua,对应的内容为 123456789101112131415#include &quot;lua.h&quot;#include &quot;lualib.h&quot;#include &quot;lauxlib.h&quot;int main()&#123; lua_State* L = luaL_newstate(); luaL_openlibs(L); luaL_dofile(L, &quot;testlua.lua&quot;); lua_close(L); return 0;&#125; 1print(&quot;xxx&quot;) 开始调试 先打断点，如图 运行如图","categories":[],"tags":[]},{"title":"hexo_note","slug":"hexo-note","date":"2023-07-13T12:42:20.000Z","updated":"2024-12-01T09:49:06.477Z","comments":true,"path":"2023/07/13/hexo-note/","link":"","permalink":"http://example.com/2023/07/13/hexo-note/","excerpt":"","text":"创建一个md文件命令hexo new xxx 123需要hexo cleanhexo d -g https://blog.csdn.net/Xupixel/article/details/120405501","categories":[],"tags":[{"name":"hexo相关命令","slug":"hexo相关命令","permalink":"http://example.com/tags/hexo%E7%9B%B8%E5%85%B3%E5%91%BD%E4%BB%A4/"}]},{"title":"游戏开发","slug":"battle","date":"2023-04-30T07:51:35.000Z","updated":"2023-07-16T02:30:56.742Z","comments":true,"path":"2023/04/30/battle/","link":"","permalink":"http://example.com/2023/04/30/battle/","excerpt":"","text":"战斗分析 战斗需要的数据(怪物) 首先需要怪物组id列表，决定玩家打几组怪物 打的回合数 攻击者的战斗列表 怪物的等级列表 客户端的其他数据(地图，是否负伤, 阵法id) 法则数据列表 初始血量列表 需知前提 怪物同样需要构造战斗列表，战力一般都是通过属性计算的 注意站位信息，3人的队伍，可能前排一个，也有可能前排两个,有啥不同呢，因为打前排和打后排伤害是不同的。 战斗最好在里面有动态测试标志。 得到攻击者和防御者的列表 数据结构为 12345678910111213141516figh_list = &#123;baseList = &#123;&#125;, &#125;baseList = &#123; modelInfo = &#123;&#125;, propData = &#123;&#125;, skillList = &#123;&#125;, passiveSkillList = &#123;&#125;, gemInfo = &#123;&#125;, assistantInfo = &#123;&#125;, assistantPropData = &#123;&#125;, assistantSkillList = &#123;&#125;, assistantPassive = &#123;&#125;, &#125; 首先遍历怪物列表，得到怪物的战斗属性，怪物超过五个的话，还有个defex结构 战斗计算所需要的一些数据 攻击者的战斗列表，防御者的战斗列表，attackex, defex,回合数，测试标志，地图id，攻击者的队伍类型站位，防御者的队伍站位，法则数据，多少回合结束算赢。 做在agent里面的战斗 使用_G.fightData &#x3D; {}，这里为啥可以这样做呢，因为agent服务是一个单线程的lua虚拟机，使用一定会按顺序计算战斗。 战斗计算流程 清除被动技能数据列表 拷贝一份战斗数据，数据结构如下 123propFight = table.deepcopy(propData)baseList.propData = table.deepcopy(propData)figh_list.baseList.propFight.baseList = figh_list.baseList 写入战报站位信息以及地图信息 12--写入站位信息及地图id &#123;攻方站位类型(0: 5人站位, 1: 3人站位 2: 1人站位), 守方站位类型, 地图id, 回合上限数, 攻方阵法id, 守方阵法id&#125;, table_insert(fightLog, &#123;attackTeamType or 0, defTeamType or 0, mapId or 0, cycNum, (attack.zhenFa and attack.zhenFa[1] or 0), (def.zhenFa and def.zhenFa[1] or 0)&#125;) 写入战报战斗初始信息，比如弟子血量和弟子法宝能量 写入战报后援数量，就是attackEx和defEx 大于一回合的时候才判断下重生和复活的技能，不可能第一回合就重生的，第一回合的时候，激活一下第一回的被动技能，其他回合判断一下循环的被动技能","categories":[],"tags":[{"name":"game-dev","slug":"game-dev","permalink":"http://example.com/tags/game-dev/"}],"author":"literwave"},{"title":"游戏开发","slug":"Interview","date":"2023-04-30T07:51:35.000Z","updated":"2024-12-01T04:55:52.345Z","comments":true,"path":"2023/04/30/Interview/","link":"","permalink":"http://example.com/2023/04/30/Interview/","excerpt":"","text":"内存对齐​ 内存对齐是为了使用空间换时间的一种策略 为什么需要内存对齐​ cpu访问内存时，并不是逐个字节访问，而是以字长为单位访问，比如64位的cpu，字长为8个字节，那么cpu访问内存的单位也是4字节。(忽略cpu访问缓存而不是内存) ​ 比如16个字节，一次读取8个字节那么只需要读取2次。 举例​ 假如有以下结构体 1234struct Test&#123; uint8_t a; uint64_t b;&#125; ​ a占一个字节，b占8个字节，如果按照内存对齐的方式，cpu只需要读取两次,第一次读取a，第二次读取b。如果不是按照内存对齐方式，第一次读取a变量，第二次读取b变量的时候，需要读取a变量，再偏移7个字节，读取第二个8字节，偏移一位。cpu需要读取三次。 规则 ​ 对于内置类型，只要它的地址是它长度的整数倍即可。 ​ 对于 struct，其中的每个数据都要对齐，struct 本身也要向其中最大的那个数据对齐。 ​ 对于 union，按照其中最长的那个数据对齐。 ​ 对于数组，无需特殊处理，因为其中每一个数据都对齐了，数组本身就对齐了。","categories":[],"tags":[{"name":"game-dev","slug":"game-dev","permalink":"http://example.com/tags/game-dev/"}],"author":"literwave"},{"title":"游戏开发之宗门大比","slug":"zmdb","date":"2023-04-20T14:01:06.000Z","updated":"2023-07-16T02:30:20.182Z","comments":true,"path":"2023/04/20/zmdb/","link":"","permalink":"http://example.com/2023/04/20/zmdb/","excerpt":"","text":"宗门大比宗门大比是策划想出来的运营活动，本质就是跨服活动战斗，和本服活动战斗，难点就是如何共享玩家的个人数据，不讨论玩家个人数据更新问题。 设计 首先呢，活动和运营活动都在activity_base里面,如果是跨服，会判断是否是跨服group_idx也就是跨服分组，也就是多少个服跨在一起，跨服也有服务器id,这设计到跨服和游戏服务器之间的rpc通信, 首先是战斗，跨服那边使用id大于30000的，作为跨服活动id，这样的好处是不管在哪都可以判断这个活动是否是跨服，当开始战斗的时候，就直接判断是运营活动，还是跨服运营活动，如果是跨服运营活动，就把战斗信息发到跨服服务器上的gameserver，如果是本服的，就直接发送游戏服的gameserver 重点是如何从跨服拿到数据呢？比如，我在运营活动的gameserver想拿弟子的数据，其实可以通过判断是否是跨服标识，来调用不同的接口去send跨服还是本服","categories":[],"tags":[{"name":"game-dev","slug":"game-dev","permalink":"http://example.com/tags/game-dev/"}]},{"title":"skynet源码分析","slug":"skynet-2","date":"2023-01-02T05:03:51.000Z","updated":"2024-04-20T10:49:45.215Z","comments":true,"path":"2023/01/02/skynet-2/","link":"","permalink":"http://example.com/2023/01/02/skynet-2/","excerpt":"","text":"前言 这是一遍关于skynet源码分析的blog,中间会对lua源码做对比 正文 skynet执行的入口文件是skynet_main.c，先来看看int main执行了些什么。 config_file是启动skynet执行的配置文件，首先会new一个lua vm,加载一下标准库，luaL_loadbufferx(L, load_config, strlen(load_config), &quot;=[skynet config]&quot;, &quot;t&quot;)是编译了load_config（lua会把代码文件看作成一个chunk，并push进栈里，也就是Lclouse,lua_pcall会根据push的clouse的类型，分别去执行(因为区分c和lua clouse)。这些的作用就是把配置文件解析出来，通过lua的全局表取出配置参数。 所有lua服务都是通过sn创建的服务 skynet_main.c文件中main函数源码注释 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354intmain(int argc, char *argv[]) &#123; const char * config_file = NULL ; if (argc &gt; 1) &#123; config_file = argv[1]; &#125; else &#123; fprintf(stderr, &quot;Need a config file. Please read skynet wiki : https://github.com/cloudwu/skynet/wiki/Config\\n&quot; &quot;usage: skynet configfilename\\n&quot;); return 1; &#125; skynet_globalinit(); / skynet_env_init(); sigign(); struct skynet_config config;#ifdef LUA_CACHELIB // init the lock of code cache luaL_initcodecache();#endif struct lua_State *L = luaL_newstate(); luaL_openlibs(L); // link lua lib int err = luaL_loadbufferx(L, load_config, strlen(load_config), &quot;=[skynet config]&quot;, &quot;t&quot;); assert(err == LUA_OK); lua_pushstring(L, config_file); err = lua_pcall(L, 1, 1, 0); if (err) &#123; fprintf(stderr,&quot;%s\\n&quot;,lua_tostring(L,-1)); lua_close(L); return 1; &#125; _init_env(L); config.thread = optint(&quot;thread&quot;,8); config.module_path = optstring(&quot;cpath&quot;,&quot;./cservice/?.so&quot;); config.harbor = optint(&quot;harbor&quot;, 1); config.bootstrap = optstring(&quot;bootstrap&quot;,&quot;snlua bootstrap&quot;); config.daemon = optstring(&quot;daemon&quot;, NULL); config.logger = optstring(&quot;logger&quot;, NULL); config.logservice = optstring(&quot;logservice&quot;, &quot;logger&quot;); config.profile = optboolean(&quot;profile&quot;, 1); lua_close(L); skynet_start(&amp;config); skynet_globalexit(); return 0;&#125;","categories":[],"tags":[{"name":"skynet源码分析","slug":"skynet源码分析","permalink":"http://example.com/tags/skynet%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"}]},{"title":"lua源码分析","slug":"lua-1","date":"2022-12-31T03:54:11.000Z","updated":"2023-06-17T07:13:01.939Z","comments":true,"path":"2022/12/31/lua-1/","link":"","permalink":"http://example.com/2022/12/31/lua-1/","excerpt":"","text":"前言 这是一篇关于lua源码分析的博客，每个阶段会有不同的理解，所以这篇博客会更新自己的认知。 正文 首先我们看的是lua.c的入口，也就是我们使用lua.exe执行lua文件的地方，从这里可以知道lua执行lua文本文件的过程。 刚开始使用luaL_newstatenew了一个lua_State结构体 数据类型 lua使用lua_TValue表示lua中所有的类型，具体如下: 123456789101112131415161718// lobject.htypedef struct lua_TValue &#123; TValuefields;&#125; TValue;#define TValuefields Value value_; int tt_/*** Union of all Lua values*/typedef union Value &#123; GCObject *gc; /* collectable objects */ void *p; /* light userdata */ int b; /* booleans */ lua_CFunction f; /* light C functions */ lua_Integer i; /* integer numbers */ lua_Number n; /* float numbers */&#125; Value; 为什么可以表示所有类型呢，如果是类似于需要垃圾回收的，就可以使用GCObject *指针表示，比如TString,Table,而其他的就表示如不需要lua进行垃圾回收,但需要释放内存的，需要靠自己释放内存; lua使用GCUnion表示使用需要垃圾回收的对象,具体如下: 12345678910111213//lstate.h/*** Union of all collectable objects (only for conversions)*/union GCUnion &#123; GCObject gc; /* common header */ struct TString ts; struct Udata u; union Closure cl; struct Table h; struct Proto p; struct lua_State th; /* thread */&#125;; 这里面每个类型都定义了一个gcobject,也就是公共头，这样可以用上面的GCObject表示，GCObject其实就是用来内存对齐的,这是使用联合体的好处。 字符串的实现 luaS_newlstr判断完是否长短字符串 123456789101112131415/*** new string (with explicit length)*/TString *luaS_newlstr (lua_State *L, const char *str, size_t l) &#123; if (l &lt;= LUAI_MAXSHORTLEN) /* short string? */ return internshrstr(L, str, l); else &#123; TString *ts; if (l &gt;= (MAX_SIZE - sizeof(TString))/sizeof(char)) luaM_toobig(L); ts = luaS_createlngstrobj(L, l); memcpy(getstr(ts), str, l * sizeof(char)); return ts; &#125;&#125; 这个是带长度的字符串 123456789101112131415161718192021/*** Create or reuse a zero-terminated string, first checking in the** cache (using the string address as a key). The cache can contain** only zero-terminated strings, so it is safe to use &#x27;strcmp&#x27; to** check hits.*/TString *luaS_new (lua_State *L, const char *str) &#123; unsigned int i = point2uint(str) % STRCACHE_N; /* hash */ int j; TString **p = G(L)-&gt;strcache[i]; for (j = 0; j &lt; STRCACHE_M; j++) &#123; if (strcmp(str, getstr(p[j])) == 0) /* hit? */ return p[j]; /* that is it */ &#125; /* normal route */ for (j = STRCACHE_M - 1; j &gt; 0; j--) p[j] = p[j - 1]; /* move out last element */ /* new element is first in the list */ p[0] = luaS_newlstr(L, str, strlen(str)); return p[0];&#125; 创建或重新使用一个带\\0终止的字符串，首次检查缓存，缓存只包含0终止的字符串，所以它是安全的，去使用strcmp去检查缓存是否存在。其实就是从strcache里面中找，如果找不到，就把p[0]缓存为新创建的字符串。 短字符串(长度小于等于40) 短字符串走internshrstr(L, str, l) 123456789101112131415161718192021222324252627282930/*** checks whether short string exists and reuses it or creates a new one*/static TString *internshrstr (lua_State *L, const char *str, size_t l) &#123; TString *ts; global_State *g = G(L); unsigned int h = luaS_hash(str, l, g-&gt;seed); TString **list = &amp;g-&gt;strt.hash[lmod(h, g-&gt;strt.size)]; lua_assert(str != NULL); /* otherwise &#x27;memcmp&#x27;/&#x27;memcpy&#x27; are undefined */ for (ts = *list; ts != NULL; ts = ts-&gt;u.hnext) &#123; if (l == ts-&gt;shrlen &amp;&amp; (memcmp(str, getstr(ts), l * sizeof(char)) == 0)) &#123; /* found! */ if (isdead(g, ts)) /* dead (but not collected yet)? */ changewhite(ts); /* resurrect it */ return ts; &#125; &#125; if (g-&gt;strt.nuse &gt;= g-&gt;strt.size &amp;&amp; g-&gt;strt.size &lt;= MAX_INT/2) &#123; luaS_resize(L, g-&gt;strt.size * 2); list = &amp;g-&gt;strt.hash[lmod(h, g-&gt;strt.size)]; /* recompute with new size */ &#125; ts = createstrobj(L, l, LUA_TSHRSTR, h); memcpy(getstr(ts), str, l * sizeof(char)); ts-&gt;shrlen = cast_byte(l); ts-&gt;u.hnext = *list; *list = ts; g-&gt;strt.nuse++; return ts;&#125; luaS_hash(str, l, g-&gt;seed);这里面是产生hash的接口，其实是根据g-&gt;seed种子去做的hash值, 1234567unsigned int luaS_hash (const char *str, size_t l, unsigned int seed) &#123; unsigned int h = seed ^ cast(unsigned int, l); size_t step = (l &gt;&gt; LUAI_HASHLIMIT) + 1; for (; l &gt;= step; l -= step) h ^= ((h&lt;&lt;5) + (h&gt;&gt;2) + cast_byte(str[l - 1])); return h;&#125; 种子去异或长度，由异或的运算可知，相同为0，不同为1；然后step右移5位,这样循环的次数会变少,关于hash算法的谈论，可以看云风大神关于lua hash函数的一点谈论，这里就不深入研究了，hash函数的设计其实就是为了减少少的碰撞,不至于吃更多的内存。 继续回到hash后面的讲解，取到g-&gt;strt.hash其实lmod其实就是为了防止不超过当前strt.size长度的大小，然后开始顺着列表开始遍历，如果产生碰撞，其实就是产生一条链子，顺着这条链表查找下去如果有申请的字符串，就使用，而且先检查长度，这样会减少strcmp的比较效率，如果找到了，判断一下字符串是否在可回收阶段，返回查找到的字符串;如果没找到，肯定是需要申请内存去放TStirng,这样肯定先检查需不需要扩容,具体如下 1234567891011121314151617181920212223242526272829/*** resizes the string table*/void luaS_resize (lua_State *L, int newsize) &#123; int i; stringtable *tb = &amp;G(L)-&gt;strt; if (newsize &gt; tb-&gt;size) &#123; /* grow table if needed */ luaM_reallocvector(L, tb-&gt;hash, tb-&gt;size, newsize, TString *); for (i = tb-&gt;size; i &lt; newsize; i++) tb-&gt;hash[i] = NULL; &#125; for (i = 0; i &lt; tb-&gt;size; i++) &#123; /* rehash */ TString *p = tb-&gt;hash[i]; tb-&gt;hash[i] = NULL; while (p) &#123; /* for each node in the list */ TString *hnext = p-&gt;u.hnext; /* save next */ unsigned int h = lmod(p-&gt;hash, newsize); /* new position */ p-&gt;u.hnext = tb-&gt;hash[h]; /* chain it */ tb-&gt;hash[h] = p; p = hnext; &#125; &#125; if (newsize &lt; tb-&gt;size) &#123; /* shrink table if needed */ /* vanishing slice should be empty */ lua_assert(tb-&gt;hash[newsize] == NULL &amp;&amp; tb-&gt;hash[tb-&gt;size - 1] == NULL); luaM_reallocvector(L, tb-&gt;hash, tb-&gt;size, newsize, TString *); &#125; tb-&gt;size = newsize;&#125; 调整大小，这个接口支持扩容和缩小，分配一个newsize * (TString *)的大小，然后把newsize-oldsize的部分初始化，赋值为空指针，再把旧的元素重新与新大小与一遍，装进新的里面。 回到createstrobj，这里采用了一个巧妙的方法，申请了一个TString的内存大小，再加上字符串的内存大小，转换为字符串的内存的时候就直接使用cast(char*, (ts)) + sizeof (UTString)，且使用ts-&gt;next = g-&gt;allgc头插法,去方便gc遍历 长字符串(长度小于等于40) 长字符串没有放进g-&gt;strt里面，而且hash值就是g-&gt;seed，简单粗暴，就是创建了一个TString对象，而且长字符串好像不需要查找原来是否有创建好的字符串，也就是说有一个就new一个。 table的实现 看下table结构体的定义，如下 1234567891011typedef struct Table &#123; CommonHeader; lu_byte flags; /* 1&lt;&lt;p means tagmethod(p) is not present */ lu_byte lsizenode; /* log2 of size of &#x27;node&#x27; array */ unsigned int sizearray; /* size of &#x27;array&#x27; array */ TValue *array; /* array part */ Node *node; Node *lastfree; /* any free position is before this position */ struct Table *metatable; GCObject *gclist;&#125; Table; 首先如何分配一个Table *luaH_new (lua_State *L)去分配一个table所需要的内存,如下 12345678910Table *luaH_new (lua_State *L) &#123; GCObject *o = luaC_newobj(L, LUA_TTABLE, sizeof(Table)); Table *t = gco2t(o); t-&gt;metatable = NULL; t-&gt;flags = cast_byte(~0); t-&gt;array = NULL; t-&gt;sizearray = 0; setnodevector(L, t, 0); return t;&#125; 这里setnodevector(L,t,0)会把hash相关的变量初始化,初始化第一个node，把key和value赋值为nil。 看一下这个table赋值的接口,如下,这个是使用key为int的时候去插入value的。 123456789101112void luaH_setint (lua_State *L, Table *t, lua_Integer key, TValue *value) &#123; const TValue *p = luaH_getint(t, key); TValue *cell; if (p != luaO_nilobject) cell = cast(TValue *, p); else &#123; TValue k; setivalue(&amp;k, key); cell = luaH_newkey(L, t, &amp;k); &#125; setobj2t(L, cell, value);&#125; 这里首先使用luaH_getint(t,key)去找这个元素，会判断这个值在数组部分还是在hash部分，如果找到了，直接覆盖原来的值，如果没找到，这个时候就需要new一个key,且返回key对应的value,这个key为啥要在hash部分呢，因为数组部分查找竟然没有，那肯定只能是在hash部分。 从luaH_newkey(L, t, &amp;k),这里是hash部分的通用接口,如下 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950TValue *luaH_newkey (lua_State *L, Table *t, const TValue *key) &#123; Node *mp; TValue aux; if (ttisnil(key)) luaG_runerror(L, &quot;table index is nil&quot;); else if (ttisfloat(key)) &#123; lua_Integer k; if (luaV_tointeger(key, &amp;k, 0)) &#123; /* does index fit in an integer? */ setivalue(&amp;aux, k); key = &amp;aux; /* insert it as an integer */ &#125; else if (luai_numisnan(fltvalue(key))) luaG_runerror(L, &quot;table index is NaN&quot;); &#125; mp = mainposition(t, key); if (!ttisnil(gval(mp)) || isdummy(t)) &#123; /* main position is taken? */ Node *othern; Node *f = getfreepos(t); /* get a free place */ if (f == NULL) &#123; /* cannot find a free place? */ rehash(L, t, key); /* grow table */ /* whatever called &#x27;newkey&#x27; takes care of TM cache */ return luaH_set(L, t, key); /* insert key into grown table */ &#125; lua_assert(!isdummy(t)); othern = mainposition(t, gkey(mp)); if (othern != mp) &#123; /* is colliding node out of its main position? */ /* yes; move colliding node into free position */ while (othern + gnext(othern) != mp) /* find previous */ othern += gnext(othern); gnext(othern) = cast_int(f - othern); /* rechain to point to &#x27;f&#x27; */ *f = *mp; /* copy colliding node into free pos. (mp-&gt;next also goes) */ if (gnext(mp) != 0) &#123; gnext(f) += cast_int(mp - f); /* correct &#x27;next&#x27; */ gnext(mp) = 0; /* now &#x27;mp&#x27; is free */ &#125; setnilvalue(gval(mp)); &#125; else &#123; /* colliding node is in its own main position */ /* new node will go into free position */ if (gnext(mp) != 0) gnext(f) = cast_int((mp + gnext(mp)) - f); /* chain new position */ else lua_assert(gnext(f) == 0); gnext(mp) = cast_int(f - mp); mp = f; &#125; &#125; setnodekey(L, &amp;mp-&gt;i_key, key); luaC_barrierback(L, t, key); lua_assert(ttisnil(gval(mp))); return gval(mp);&#125; 首先，先翻译这个解释把，插入一个新key到hash table，首先检查key的mp位置是否是空闲的，如果不是，检查碰撞的节点它本来的位置是否在这个mp，如果不是,移动这个碰撞的节点放入空的位置,新key放入它自己的mp;除此之外，碰撞的节点在它自己的mp，新key直接放入空的位置。 分析一下mainposition方法,如下 12345678910111213141516171819202122232425/*** returns the &#x27;main&#x27; position of an element in a table (that is, the index** of its hash value)*/static Node *mainposition (const Table *t, const TValue *key) &#123; switch (ttype(key)) &#123; case LUA_TNUMINT: return hashint(t, ivalue(key)); case LUA_TNUMFLT: return hashmod(t, l_hashfloat(fltvalue(key))); case LUA_TSHRSTR: return hashstr(t, tsvalue(key)); case LUA_TLNGSTR: return hashpow2(t, luaS_hashlongstr(tsvalue(key))); case LUA_TBOOLEAN: return hashboolean(t, bvalue(key)); case LUA_TLIGHTUSERDATA: return hashpointer(t, pvalue(key)); case LUA_TLCF: return hashpointer(t, fvalue(key)); default: lua_assert(!ttisdeadkey(key)); return hashpointer(t, gcvalue(key)); &#125;&#125; 函数的作用就是取table的key对应node的位置，如果是int类型，hash出来就是int&amp;lsizenode的值 如果是mp位置不为 nil，或者没有元素，首先获取一个空闲位置freemp,如果没有的话，就需要调整表的大小,也就是rehash(L, t, key)重新hash,如下 123456789101112131415161718192021/*** nums[i] = number of keys &#x27;k&#x27; where 2^(i - 1) &lt; k &lt;= 2^i*/static void rehash (lua_State *L, Table *t, const TValue *ek) &#123; unsigned int asize; /* optimal size for array part */ unsigned int na; /* number of keys in the array part */ unsigned int nums[MAXABITS + 1]; int i; int totaluse; for (i = 0; i &lt;= MAXABITS; i++) nums[i] = 0; /* reset counts */ na = numusearray(t, nums); /* count keys in array part */ totaluse = na; /* all those keys are integer keys */ totaluse += numusehash(t, nums, &amp;na); /* count keys in hash part */ /* count extra key */ na += countint(ek, nums); totaluse++; /* compute new size for array part */ asize = computesizes(nums, &amp;na); /* resize the table to new computed sizes */ luaH_resize(L, t, asize, totaluse - na);&#125; nums[32]，然后初始化nums[i] = 0,na表示数组里面有多少keys,具体代码如下 1234567891011121314151617181920212223242526272829/*** Count keys in array part of table &#x27;t&#x27;: Fill &#x27;nums[i]&#x27; with** number of keys that will go into corresponding slice and return** total number of non-nil keys.*/static unsigned int numusearray (const Table *t, unsigned int *nums) &#123; int lg; unsigned int ttlg; /* 2^lg */ unsigned int ause = 0; /* summation of &#x27;nums&#x27; */ unsigned int i = 1; /* count to traverse all array keys */ /* traverse each slice */ for (lg = 0, ttlg = 1; lg &lt;= MAXABITS; lg++, ttlg *= 2) &#123; unsigned int lc = 0; /* counter */ unsigned int lim = ttlg; if (lim &gt; t-&gt;sizearray) &#123; lim = t-&gt;sizearray; /* adjust upper limit */ if (i &gt; lim) break; /* no more elements to count */ &#125; /* count elements in range (2^(lg - 1), 2^lg] */ for (; i &lt;= lim; i++) &#123; if (!ttisnil(&amp;t-&gt;array[i-1])) lc++; &#125; nums[lg] += lc; ause += lc; &#125; return ause;&#125; 各变量的含义，其实变量limit，就是防止超出数组大小,count elements in range (2^(lg - 1), 2^lg],i就是保存下遍历到多少了，这样就得到数组部分位图和总共使用的数量。 hash部分的统计元素有点巧妙，如下 1234567891011121314151617181920212223242526272829303132333435363738394041424344static int numusehash (const Table *t, unsigned int *nums, unsigned int *pna) &#123; int totaluse = 0; /* total number of elements */ int ause = 0; /* elements added to &#x27;nums&#x27; (can go to array part) */ int i = sizenode(t); while (i--) &#123; Node *n = &amp;t-&gt;node[i]; if (!ttisnil(gval(n))) &#123; ause += countint(gkey(n), nums); totaluse++; &#125; &#125; *pna += ause; return totaluse;&#125;static int countint (const TValue *key, unsigned int *nums) &#123; unsigned int k = arrayindex(key); if (k != 0) &#123; /* is &#x27;key&#x27; an appropriate array index? */ nums[luaO_ceillog2(k)]++; /* count as such */ return 1; &#125; else return 0;&#125;/*** Computes ceil(log2(x))*/int luaO_ceillog2 (unsigned int x) &#123; static const lu_byte log_2[256] = &#123; /* log_2[i] = ceil(log2(i - 1)) */ 0,1,2,2,3,3,3,3,4,4,4,4,4,4,4,4,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5, 6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6, 7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7, 7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7, 8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8, 8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8, 8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8, 8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8 &#125;; int l = 0; x--; while (x &gt;= 256) &#123; l += 8; x &gt;&gt;= 8; &#125; return l + log_2[x];&#125; 首先只统计值不是nil的元素的key,重点看一下luaO_ceillog2,这样循环会减少遍历，类似于空间换时间；其实log_2[i]表示的是 2^log_2[i] &gt;= i也就是log_2[i] = ceil(log2(i - 1)),如果大于256说明一定是在2^8方以上, 在加上新增加的key。 computesizes(nums, &amp;na)就是重新计算大小了，如下 12345678910111213141516171819202122232425262728293031323334353637383940/*** Compute the optimal size for the array part of table &#x27;t&#x27;. &#x27;nums&#x27; is a** &quot;count array&quot; where &#x27;nums[i]&#x27; is the number of integers in the table** between 2^(i - 1) + 1 and 2^i. &#x27;pna&#x27; enters with the total number of** integer keys in the table and leaves with the number of keys that** will go to the array part; return the optimal size.*/static unsigned int computesizes (unsigned int nums[], unsigned int *pna) &#123; int i; unsigned int twotoi; /* 2^i (candidate for optimal size) */ unsigned int a = 0; /* number of elements smaller than 2^i */ unsigned int na = 0; /* number of elements to go to array part */ unsigned int optimal = 0; /* optimal size for array part */ /* loop while keys can fill more than half of total size */ for (i = 0, twotoi = 1; twotoi &gt; 0 &amp;&amp; *pna &gt; twotoi / 2; i++, twotoi *= 2) &#123; if (nums[i] &gt; 0) &#123; a += nums[i]; if (a &gt; twotoi/2) &#123; /* more than half elements present? */ optimal = twotoi; /* optimal size (till now) */ na = a; /* all elements up to &#x27;optimal&#x27; will go to array part */ &#125; &#125; &#125; lua_assert((optimal == 0 || optimal / 2 &lt; na) &amp;&amp; na &lt;= optimal); *pna = na; return optimal;&#125;static int countint (const TValue *key, unsigned int *nums) &#123; unsigned int k = arrayindex(key); if (k != 0) &#123; /* is &#x27;key&#x27; an appropriate array index? */ nums[luaO_ceillog2(k)]++; /* count as such */ return 1; &#125; else return 0;&#125; 接下来重点分析下解决放入元素的问题，直接在代码里面写注释比较好 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081TValue *luaH_newkey (lua_State *L, Table *t, const TValue *key) &#123; Node *mp; TValue aux; if (ttisnil(key)) luaG_runerror(L, &quot;table index is nil&quot;); else if (ttisfloat(key)) &#123; lua_Integer k; if (luaV_tointeger(key, &amp;k, 0)) &#123; /* does index fit in an integer? */ setivalue(&amp;aux, k); key = &amp;aux; /* insert it as an integer */ &#125; else if (luai_numisnan(fltvalue(key))) luaG_runerror(L, &quot;table index is NaN&quot;); &#125; /* mp是根据key根据hash得到node的地址, */ mp = mainposition(t, key); /* 如果发现node里的value不是nilobj,或者是第一个元素的话,也就是当为hash碰撞了 */ if (!ttisnil(gval(mp)) || isdummy(t)) &#123; /* main position is taken? */ /* 开始找空闲位置,空闲位置是从最后一个node[i]的位置，开始往左边找 */ Node *othern; Node *f = getfreepos(t); /* get a free place */ if (f == NULL) &#123; /* cannot find a free place? */ /* 没有空闲位置就直接扩大hash表的容量 */ rehash(L, t, key); /* grow table */ /* whatever called &#x27;newkey&#x27; takes care of TM cache */ return luaH_set(L, t, key); /* insert key into grown table */ &#125; lua_assert(!isdummy(t)); /* 取一下在这个位置node[i]的key，然后找一下它本来在的位置 情况1：原本位置不在这 情况2：位置本来是在这里 */ othern = mainposition(t, gkey(mp)); if (othern != mp) &#123; /* is colliding node out of its main position? */ /* yes; move colliding node into free position */ /* 当本来位置不在这里的时候,从他本来的位置开始找 othern-&gt;ikey.next -&gt;...-&gt;mp 一定会串起来 othern-&gt;ikey.next = 到空闲位置f的距离 空闲位置f = mp f-&gt;next = mp - f 好处应该是尽量hash一次到这个位置 */ while (othern + gnext(othern) != mp) /* find previous */ othern += gnext(othern); gnext(othern) = cast_int(f - othern); /* rechain to point to &#x27;f&#x27; */ *f = *mp; /* copy colliding node into free pos. (mp-&gt;next also goes) */ if (gnext(mp) != 0) &#123; gnext(f) += cast_int(mp - f); /* correct &#x27;next&#x27; */ gnext(mp) = 0; /* now &#x27;mp&#x27; is free */ &#125; setnilvalue(gval(mp)); &#125; else &#123; /* colliding node is in its own main position */ /* new node will go into free position */ /* 它的key根据hash就在原本的位置了 mp = f f也就是新放入key的元素了 */ if (gnext(mp) != 0) gnext(f) = cast_int((mp + gnext(mp)) - f); /* chain new position */ else lua_assert(gnext(f) == 0); gnext(mp) = cast_int(f - mp); mp = f; &#125; &#125; setnodekey(L, &amp;mp-&gt;i_key, key); luaC_barrierback(L, t, key); lua_assert(ttisnil(gval(mp))); return gval(mp);&#125; luaL_newstate()讲解lua异常处理机制 lua异常处理机制是通过setjmp和longjmp实现的，当longjmp(jmp_buf b, 2)程序会回到setjmp重新执行，且返回值是longjmp的第二个参数;lua就是通过lua_longjmp结构体的status来判断虚拟机是否成功调用函数 lua垃圾回收机制 lua采用增量式标记-清除算法,","categories":[],"tags":[{"name":"lua源码","slug":"lua源码","permalink":"http://example.com/tags/lua%E6%BA%90%E7%A0%81/"}]},{"title":"skynet example main分析","slug":"skynet-1","date":"2022-12-11T04:44:56.000Z","updated":"2022-12-24T09:01:11.607Z","comments":true,"path":"2022/12/11/skynet-1/","link":"","permalink":"http://example.com/2022/12/11/skynet-1/","excerpt":"","text":"前言 之前刚看skynet的时候就一直看skynet example的例子，想想这些例子对于新人来说不妨说是入门的时候必看的，也有必要理清一下流程，以防之后再看，得重新梳理一遍，这边blog不会过多关心api的使用 正文 启动流程 任何程序，都有一个入口程序，而skynet这个框架的入口是配置在config start里面(只是从框架层面来说，不涉及底层)，example的入口程序是main.lua不是登录的main.lua哦，其实就是注意下lua的搜索路径。 代码如下 12345678910111213141516171819202122local skynet = require &quot;skynet&quot;local sprotoloader = require &quot;sprotoloader&quot;local max_client = 64skynet.start(function() skynet.error(&quot;Server start&quot;) skynet.uniqueservice(&quot;protoloader&quot;) if not skynet.getenv &quot;daemon&quot; then local console = skynet.newservice(&quot;console&quot;) end skynet.newservice(&quot;debug_console&quot;,8000) skynet.newservice(&quot;simpledb&quot;) local watchdog = skynet.newservice(&quot;watchdog&quot;) skynet.call(watchdog, &quot;lua&quot;, &quot;start&quot;, &#123; port = 8888, maxclient = max_client, nodelay = true, &#125;) skynet.error(&quot;Watchdog listen on&quot;, 8888) skynet.exit()end) 这部分代码作用如下 启动protoloader服务 是否启动console服务 启动debug_console服务 启动simpledb服务 启动watchdog服务 通信协议服务 wait… 看门狗服务 skynet.start 初始化服务，并启动网关。 watchdog里的变量gate保存的是网关服务的地址 网关服务 调用gateserver.start(handler)启动网关服务 注册socket消息的解包方式和回调函数 12345678910111213skynet.register_protocol &#123; name = &quot;socket&quot;, id = skynet.PTYPE_SOCKET, -- PTYPE_SOCKET = 6 unpack = function ( msg, sz ) return netpack.filter( queue, msg, sz) end, dispatch = function (_, _, q, type, ...) queue = q if type then MSG[type](...) end end&#125; 一旦有socket消息，就会调用unpack的分包，再调用到MSG的回调函数。为啥需要queue？因为这个是处理粘包时候的逻辑。 粘包的时候会使用dispatch_queue()去处理分包，从queue里面pop一个元素 使用init()初始化服务 这个时候main.lua会call watchdog服务，watchdog服务会call网关服务监听套接字，执行网关服务的CMD.open,监听配置的地址和端口，这个时候逻辑就执行完了，不会阻塞在listen里的，待研究… 客户端开始连接套接字，这个时候gateserver.lua会使用socketdriver.start,判断一下gate模块是否有open函数，开始回调，gate模块记录下watchdog服务的地址。之后socket的第一条消息是open，也就是调用到MSG.open(fd,msg)会做一些限流操作，也就是连接客户端的上限，设置connect[fd] = true表示客户端已经连接上网关模块了。然后回调到gate模块的connect，gate模块会保存一份 connect[fd] = &#123;fd = fd , ip = addr&#125;,再send一条消息到watchdog服务上，告诉watchdog客户端的套接字和地址，这个时候watchdog开始new一个agent服务，也就是玩家服务，watchdog变量agent[fd] = 玩家服务地址，agent服务初始化的时候注册了一个客户端的消息，定义了解包和回调函数。watchdog服务再call玩家服务，这样子玩家服务就保存了套接字的地址和网关模块的地址和watchdog的地址。这个时候可以执行心跳包逻辑，再call网关服务回调forward(source, fd, client, address)，这个时候网关模块完善了connect[fd] = &#123;fd = fd ,ip = addr, client = 0, c.agent = source&#125; 而forwarding[c.agent] = c这样就能根据agent的地址找到fd，根据fd能知道对应agent,这个时候启动gateserver开始启动收发数据，也就是gateserver.openclient,也就是启动socketdriver.start(fd)这个时候才是建立了和客户端的连接 再讲一下消息处理,也就是MSG.data，会回调到gate的message(fd, msg, sz)，这个时候会取出fd对应的agent使用skynet.redirect()伪造是客户端直接发给玩家的包。","categories":[],"tags":[{"name":"skynet","slug":"skynet","permalink":"http://example.com/tags/skynet/"}]},{"title":"csapp","slug":"csapp","date":"2022-12-03T10:21:42.000Z","updated":"2023-06-27T16:26:13.500Z","comments":true,"path":"2022/12/03/csapp/","link":"","permalink":"http://example.com/2022/12/03/csapp/","excerpt":"","text":"c语言编译过程 预处理 1g++ -E test.cpp -o test.i 编译 1g++ -S test.i - o test.s 汇编 1g++ -c test.s -o test.o 链接 g++ test.o -o test 1234567c语言编译参数* -O[n]优化源代码,一般用`-O2`* -l和-L 链接glog库 g++ -lglog test.cpp -l 参数在/lib和/usr/lib/和/usr/local/lib里的库 如果库没有在上面三个目录里，需要使用-L参数指定库文件所在目录 123* -I指定头文件搜索目录 -I 默认在/usr/include目录 1234567891011* -Wall 打印警告信息* -w 关闭警告信息* -std = c++11设置编译标准* -o 指定输出文件名* -D 定义宏 在使用gcc/g++编译的时候定义宏 #include&lt;stdio.h&gt; int main() &#123; #ifdef DEBUG printf(&quot;DEBUG LOG\\n&quot;); #endif printf(&quot;in\\n&quot;); &#125; g++ -DDEBUG main.cpp 执行第一行打印 1234567891011121314151617181920### c语言生成静态库* 首先生成.o的二进制文件,然后用ar生成.a的文件`ar rs x.a x.o`，静态库以.a结尾的### c语言生成动态库* `gcc x.cpp -I../include -fPIC -shared -o x.so` 等价于这两条分开* `gcc x.cpp -I../include -c fPIC`;`gcc -shared -o x.so x.o `### 为什么需要生成库呢* 因为需要隐藏实现细节,这样就可以封装给别人用，别人看不到源代码### 动态库和静态库的区别* 静态库可以直接运行 ```bash ./xxx 动态库需要 1LD_LIBRARY_PATH = src ./xx gdb调试器 g++ -g xx.cpp -o a_yes_g c语言分析器 (float (*h)() *h &#x3D; 函数 h就是指向函数的指针","categories":[],"tags":[]},{"title":"游戏开发","slug":"game-dev","date":"2022-12-03T07:21:21.000Z","updated":"2022-12-11T04:32:38.076Z","comments":true,"path":"2022/12/03/game-dev/","link":"","permalink":"http://example.com/2022/12/03/game-dev/","excerpt":"","text":"目标活动 前几天在开发一个子活动，突然发现一个问题还蛮容易疏忽的。 我们的活动框架类似于这样的，存储结构，&#123;[大活动id][子活动id][玩家id]&#125; 然后策划需求是这样的，经典对需求，类似玩家达到某个条件，然后记录进度。 说说我的设计吧，起初我在大活动模块里回调到各个子活动onstart函数，也就是活动开始的时候取单服所有玩家的数据把目标任务加上去。然后就交给策划验收了，策划用新号，发现，目标任务居然全都完成了(当客户端没数据的时候，会默认所有任务都完成了)，原因就是拿单服所有玩家的时候发现新进入的玩家是没有这个任务目标的，所有就出现bug了，这个问题在开发设计中是个坑，所有记录一下。 我目前的处理就是，不能在登录的时候给玩家接取，因为当开始的时候，玩家在线客户端是不会发现有目标任务数据的，所以我在活动开启的时候只接取在线玩家的，如果有离线玩家的，只能通过登录来接取了。 最终修改 这种还是不合理，因为这种耦合性太强了，其实就是策划配错表了，这样会导致出错率太高了。 现在修改为，在活动开始的时候可以onstart ,但是呢，这个时候，是不会取所有玩家接取的，只会注册任务回调函数而已，在触发的时候，根据type_id取一下开启的活动，然后遍历一下这个活动是否有这个任务，这样子不仅仅保证策划动态改任务了，而且还支持所有玩家一上线就能拿到任务。","categories":[],"tags":[{"name":"game-dev","slug":"game-dev","permalink":"http://example.com/tags/game-dev/"}],"author":"literwave"},{"title":"一次mysql源码安装","slug":"mysql","date":"2022-11-27T07:20:25.000Z","updated":"2022-12-11T04:31:37.531Z","comments":true,"path":"2022/11/27/mysql/","link":"","permalink":"http://example.com/2022/11/27/mysql/","excerpt":"","text":"需要准备的条件 cmake gcc boost1.59.0 这里贴出我对应的依赖版本(由于图片加载太慢了) 12camke version 3.25.0-rclgcc (GCC) 12.2.0 mysql版本对应的依赖boost版本必须要匹配，编译过程如果有报错信息boost要求对应的版本 这里选择的是mysql5.7.17,mysql源码链接 boost对应的版本库,选择需要的版本对应download就行,boost版本 下载对应好需要的依赖就行,就开始解压过程，以mysql源码为例子 123cd /home/soft/wget https://github.com/mysql/mysql-server/archive/mysql-5.7.17.tar.gztar xzfv mysql-5.7.17.tar.gz 这个时候需要给mysql一些文件权限，不然mysql如何操作文件呢？ 123cd mysql-server-mysql-5.7.17/groupadd mysqluseradd -r -g mysql -s /bin/false mysql 配置mysql预编译参数 创建mysql数据存储目录 1mkdir -p /usr/local/mysql/data 预编译参数(根据自身依赖的情况，去选择文件路径) 12345678cmake . -DCMAKE_INSTALL_PREFIX=/usr/local/mysql \\-DMYSQL_DATADIR=/usr/local/mysql/data \\-DWITH_BOOST=/data/soft/boost_1_59_0 \\-DSYSCONFDIR=/etc \\-DEFAULT_CHARSET=utf8mb4 \\-DDEFAULT_COLLATION=utf8mb4_general_ci \\-DENABLED_LOCAL_INFILE=1 \\-DEXTRA_CHARSETS=all 编译并安装 12make -j `grep processor /proc/cpuinfo | wc -l`make install 编译完成后 12345678cd /usr/local/mysqlchown -R mysql:mysql .# 注意：MySQL 5.7.6之前的版本执行这个脚本初始化系统数据库./bin/mysql_install_db --user=mysql --basedir=/usr/local/mysql --datadir=/usr/local/mysql/datachown -R root .chown -R mysql datachmod -R 777 data 新建配置文件 1vim /etc/my.cnf 新建日志文件 12345678910mkdir -p /usr/local/mysql/logcd /usr/local/mysql/logtouch mysql_error.logtouch mysql_slow.logcd ..chown -R mysql logchmod -R 777 log 配置文件内容innodb_buffer_pool_size注意下 看自己内存有多少，再分配，以防内存不够报错。skip-grant-tables这里跳过mysql验证的配置，方便我们到时候改密码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970[client]port=3306socket=/usr/local/mysql/mysql.sock[mysqld]character-set-server=utf8collation-server=utf8_general_ciskip-external-lockingskip-name-resolveskip-grant-tablesfederatedexplicit_defaults_for_timestamp = 1user=mysqlport=3306basedir=/usr/local/mysqldatadir=/usr/local/mysql/datatmpdir=/usr/local/mysql/temp# server_id = .....socket=/usr/local/mysql/mysql.socklog-error=/usr/local/mysql/log/mysql_error.logpid-file=/usr/local/mysql/mysql.pidopen_files_limit=10240back_log=600max_connections=500max_connect_errors=6000wait_timeout=605800#open_tables=600#table_cache = 650#opened_tables = 630max_allowed_packet=32Msort_buffer_size=4Mjoin_buffer_size=4Mthread_cache_size=300query_cache_type=1query_cache_size=256Mquery_cache_limit=2Mquery_cache_min_res_unit=16ktmp_table_size=256Mmax_heap_table_size=256Mkey_buffer_size=256Mread_buffer_size=1Mread_rnd_buffer_size=16Mbulk_insert_buffer_size=64Mlower_case_table_names=1default-storage-engine=INNODBinnodb_buffer_pool_size=1Ginnodb_log_buffer_size=32Minnodb_log_file_size=128Minnodb_flush_method=O_DIRECT######################thread_concurrency=32long_query_time=2slow-query-log=onslow-query-log-file=/usr/local/mysql/log/mysql_slow.log[mysqldump]quickmax_allowed_packet=32M[mysqld_safe]log-error=/var/log/mysqld.logpid-file=/var/run/mysqld/mysqld.pid 配置mysql服务 123cp support-files/mysql.server /etc/init.d/mysqldchkconfig --add mysqld # 添加到系统服务chkconfig mysqld on # 开机启动 接下来我们就可以使用systemctl start mysqld启动服务了，但是每个人安装不一样，总会有不同的报错，这个时候看下tail -f /var/log/mysqld.log看下对应报啥错，有时候大多是忘记设计权限了 12345systemctl restart mysqld -- 重启mysqlsystemctl stop mysqld -- 停止mysql服务systemctl status mysqld -- 查看mysql服务状态systemctl daemon-reload -- 如果重新设置了服务，可以使用这个重载一下 配置一下可以直接使用mysql的命令吧 1234vim /etc/profileexport PATH=$PATH:/usr/local/mysql/binsource /etc/profile 接下来就是更改密码了 因为我们配置了skip-grant-tables,所以第一次认证，直接使用这样的 12mysql -uroot -p回车 设置新密码 1234use mysql;update user set authentication_string=password(&#x27;新密码&#x27;) where user=&#x27;root&#x27;; flush privileges; 注意把skip-grant-tables注释掉，重新启动mysql服务 重新编译记得清下编译的时候的缓存文件 123cd /data/soft/mysqlrm -f CMakeCache.txtmake clean mysql安装完毕，接下来查看下mysql进程 1ps -aux | grep mysql 一些报错产生的原因，可以参考这个博客，报错原因","categories":[],"tags":[{"name":"mysql","slug":"mysql","permalink":"http://example.com/tags/mysql/"}]}],"categories":[],"tags":[{"name":"hexo相关命令","slug":"hexo相关命令","permalink":"http://example.com/tags/hexo%E7%9B%B8%E5%85%B3%E5%91%BD%E4%BB%A4/"},{"name":"game-dev","slug":"game-dev","permalink":"http://example.com/tags/game-dev/"},{"name":"skynet源码分析","slug":"skynet源码分析","permalink":"http://example.com/tags/skynet%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"},{"name":"lua源码","slug":"lua源码","permalink":"http://example.com/tags/lua%E6%BA%90%E7%A0%81/"},{"name":"skynet","slug":"skynet","permalink":"http://example.com/tags/skynet/"},{"name":"mysql","slug":"mysql","permalink":"http://example.com/tags/mysql/"}]}