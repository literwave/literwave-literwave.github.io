{"meta":{"title":"game development","subtitle":"","description":"","author":"John Doe","url":"http://example.com","root":"/"},"pages":[{"title":"[404]","date":"2022-11-27T05:59:15.129Z","updated":"2022-11-27T05:59:15.129Z","comments":true,"path":"404.html","permalink":"http://example.com/404.html","excerpt":"","text":""},{"title":"","date":"2022-11-27T06:06:11.442Z","updated":"2022-11-27T06:06:11.442Z","comments":true,"path":"about/index.html","permalink":"http://example.com/about/index.html","excerpt":"","text":"​—title:自我介绍标题layout:about​—literwave来源于我叫小波"}],"posts":[{"title":"skynet example main分析","slug":"skynet-1","date":"2022-12-11T04:44:56.000Z","updated":"2022-12-24T09:01:11.607Z","comments":true,"path":"2022/12/11/skynet-1/","link":"","permalink":"http://example.com/2022/12/11/skynet-1/","excerpt":"","text":"前言 之前刚看skynet的时候就一直看skynet example的例子，想想这些例子对于新人来说不妨说是入门的时候必看的，也有必要理清一下流程，以防之后再看，得重新梳理一遍，这边blog不会过多关心api的使用 正文 启动流程 任何程序，都有一个入口程序，而skynet这个框架的入口是配置在config start里面(只是从框架层面来说，不涉及底层)，example的入口程序是main.lua不是登录的main.lua哦，其实就是注意下lua的搜索路径。 代码如下 12345678910111213141516171819202122local skynet = require &quot;skynet&quot;local sprotoloader = require &quot;sprotoloader&quot;local max_client = 64skynet.start(function() skynet.error(&quot;Server start&quot;) skynet.uniqueservice(&quot;protoloader&quot;) if not skynet.getenv &quot;daemon&quot; then local console = skynet.newservice(&quot;console&quot;) end skynet.newservice(&quot;debug_console&quot;,8000) skynet.newservice(&quot;simpledb&quot;) local watchdog = skynet.newservice(&quot;watchdog&quot;) skynet.call(watchdog, &quot;lua&quot;, &quot;start&quot;, &#123; port = 8888, maxclient = max_client, nodelay = true, &#125;) skynet.error(&quot;Watchdog listen on&quot;, 8888) skynet.exit()end) 这部分代码作用如下 启动protoloader服务 是否启动console服务 启动debug_console服务 启动simpledb服务 启动watchdog服务 通信协议服务 wait… 看门狗服务 skynet.start 初始化服务，并启动网关。 watchdog里的变量gate保存的是网关服务的地址 网关服务 调用gateserver.start(handler)启动网关服务 注册socket消息的解包方式和回调函数 12345678910111213skynet.register_protocol &#123; name = &quot;socket&quot;, id = skynet.PTYPE_SOCKET, -- PTYPE_SOCKET = 6 unpack = function ( msg, sz ) return netpack.filter( queue, msg, sz) end, dispatch = function (_, _, q, type, ...) queue = q if type then MSG[type](...) end end&#125; 一旦有socket消息，就会调用unpack的分包，再调用到MSG的回调函数。为啥需要queue？因为这个是处理粘包时候的逻辑。 粘包的时候会使用dispatch_queue()去处理分包，从queue里面pop一个元素 使用init()初始化服务 这个时候main.lua会call watchdog服务，watchdog服务会call网关服务监听套接字，执行网关服务的CMD.open,监听配置的地址和端口，这个时候逻辑就执行完了，不会阻塞在listen里的，待研究… 客户端开始连接套接字，这个时候gateserver.lua会使用socketdriver.start,判断一下gate模块是否有open函数，开始回调，gate模块记录下watchdog服务的地址。之后socket的第一条消息是open，也就是调用到MSG.open(fd,msg)会做一些限流操作，也就是连接客户端的上限，设置connect[fd] = true表示客户端已经连接上网关模块了。然后回调到gate模块的connect，gate模块会保存一份 connect[fd] = &#123;fd = fd , ip = addr&#125;,再send一条消息到watchdog服务上，告诉watchdog客户端的套接字和地址，这个时候watchdog开始new一个agent服务，也就是玩家服务，watchdog变量agent[fd] = 玩家服务地址，agent服务初始化的时候注册了一个客户端的消息，定义了解包和回调函数。watchdog服务再call玩家服务，这样子玩家服务就保存了套接字的地址和网关模块的地址和watchdog的地址。这个时候可以执行心跳包逻辑，再call网关服务回调forward(source, fd, client, address)，这个时候网关模块完善了connect[fd] = &#123;fd = fd ,ip = addr, client = 0, c.agent = source&#125; 而forwarding[c.agent] = c这样就能根据agent的地址找到fd，根据fd能知道对应agent,这个时候启动gateserver开始启动收发数据，也就是gateserver.openclient,也就是启动socketdriver.start(fd)这个时候才是建立了和客户端的连接 再讲一下消息处理,也就是MSG.data，会回调到gate的message(fd, msg, sz)，这个时候会取出fd对应的agent使用skynet.redirect()伪造是客户端直接发给玩家的包。","categories":[],"tags":[{"name":"skynet","slug":"skynet","permalink":"http://example.com/tags/skynet/"}]},{"title":"csapp","slug":"csapp","date":"2022-12-03T10:21:42.000Z","updated":"2022-12-11T04:45:02.191Z","comments":true,"path":"2022/12/03/csapp/","link":"","permalink":"http://example.com/2022/12/03/csapp/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"游戏开发","slug":"game-dev","date":"2022-12-03T07:21:21.000Z","updated":"2022-12-11T04:32:38.076Z","comments":true,"path":"2022/12/03/game-dev/","link":"","permalink":"http://example.com/2022/12/03/game-dev/","excerpt":"","text":"目标活动 前几天在开发一个子活动，突然发现一个问题还蛮容易疏忽的。 我们的活动框架类似于这样的，存储结构，&#123;[大活动id][子活动id][玩家id]&#125; 然后策划需求是这样的，经典对需求，类似玩家达到某个条件，然后记录进度。 说说我的设计吧，起初我在大活动模块里回调到各个子活动onstart函数，也就是活动开始的时候取单服所有玩家的数据把目标任务加上去。然后就交给策划验收了，策划用新号，发现，目标任务居然全都完成了(当客户端没数据的时候，会默认所有任务都完成了)，原因就是拿单服所有玩家的时候发现新进入的玩家是没有这个任务目标的，所有就出现bug了，这个问题在开发设计中是个坑，所有记录一下。 我目前的处理就是，不能在登录的时候给玩家接取，因为当开始的时候，玩家在线客户端是不会发现有目标任务数据的，所以我在活动开启的时候只接取在线玩家的，如果有离线玩家的，只能通过登录来接取了。 最终修改 这种还是不合理，因为这种耦合性太强了，其实就是策划配错表了，这样会导致出错率太高了。 现在修改为，在活动开始的时候可以onstart ,但是呢，这个时候，是不会取所有玩家接取的，只会注册任务回调函数而已，在触发的时候，根据type_id取一下开启的活动，然后遍历一下这个活动是否有这个任务，这样子不仅仅保证策划动态改任务了，而且还支持所有玩家一上线就能拿到任务。","categories":[],"tags":[{"name":"game-dev","slug":"game-dev","permalink":"http://example.com/tags/game-dev/"}],"author":"literwave"},{"title":"一次mysql源码安装","slug":"mysql","date":"2022-11-27T07:20:25.000Z","updated":"2022-12-11T04:31:37.531Z","comments":true,"path":"2022/11/27/mysql/","link":"","permalink":"http://example.com/2022/11/27/mysql/","excerpt":"","text":"需要准备的条件 cmake gcc boost1.59.0 这里贴出我对应的依赖版本(由于图片加载太慢了) 12camke version 3.25.0-rclgcc (GCC) 12.2.0 mysql版本对应的依赖boost版本必须要匹配，编译过程如果有报错信息boost要求对应的版本 这里选择的是mysql5.7.17,mysql源码链接 boost对应的版本库,选择需要的版本对应download就行,boost版本 下载对应好需要的依赖就行,就开始解压过程，以mysql源码为例子 123cd /home/soft/wget https://github.com/mysql/mysql-server/archive/mysql-5.7.17.tar.gztar xzfv mysql-5.7.17.tar.gz 这个时候需要给mysql一些文件权限，不然mysql如何操作文件呢？ 123cd mysql-server-mysql-5.7.17/groupadd mysqluseradd -r -g mysql -s /bin/false mysql 配置mysql预编译参数 创建mysql数据存储目录 1mkdir -p /usr/local/mysql/data 预编译参数(根据自身依赖的情况，去选择文件路径) 12345678cmake . -DCMAKE_INSTALL_PREFIX=/usr/local/mysql \\-DMYSQL_DATADIR=/usr/local/mysql/data \\-DWITH_BOOST=/data/soft/boost_1_59_0 \\-DSYSCONFDIR=/etc \\-DEFAULT_CHARSET=utf8mb4 \\-DDEFAULT_COLLATION=utf8mb4_general_ci \\-DENABLED_LOCAL_INFILE=1 \\-DEXTRA_CHARSETS=all 编译并安装 12make -j `grep processor /proc/cpuinfo | wc -l`make install 编译完成后 12345678cd /usr/local/mysqlchown -R mysql:mysql .# 注意：MySQL 5.7.6之前的版本执行这个脚本初始化系统数据库./bin/mysql_install_db --user=mysql --basedir=/usr/local/mysql --datadir=/usr/local/mysql/datachown -R root .chown -R mysql datachmod -R 777 data 新建配置文件 1vim /etc/my.cnf 新建日志文件 12345678910mkdir -p /usr/local/mysql/logcd /usr/local/mysql/logtouch mysql_error.logtouch mysql_slow.logcd ..chown -R mysql logchmod -R 777 log 配置文件内容innodb_buffer_pool_size注意下 看自己内存有多少，再分配，以防内存不够报错。skip-grant-tables这里跳过mysql验证的配置，方便我们到时候改密码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970[client]port=3306socket=/usr/local/mysql/mysql.sock[mysqld]character-set-server=utf8collation-server=utf8_general_ciskip-external-lockingskip-name-resolveskip-grant-tablesfederatedexplicit_defaults_for_timestamp = 1user=mysqlport=3306basedir=/usr/local/mysqldatadir=/usr/local/mysql/datatmpdir=/usr/local/mysql/temp# server_id = .....socket=/usr/local/mysql/mysql.socklog-error=/usr/local/mysql/log/mysql_error.logpid-file=/usr/local/mysql/mysql.pidopen_files_limit=10240back_log=600max_connections=500max_connect_errors=6000wait_timeout=605800#open_tables=600#table_cache = 650#opened_tables = 630max_allowed_packet=32Msort_buffer_size=4Mjoin_buffer_size=4Mthread_cache_size=300query_cache_type=1query_cache_size=256Mquery_cache_limit=2Mquery_cache_min_res_unit=16ktmp_table_size=256Mmax_heap_table_size=256Mkey_buffer_size=256Mread_buffer_size=1Mread_rnd_buffer_size=16Mbulk_insert_buffer_size=64Mlower_case_table_names=1default-storage-engine=INNODBinnodb_buffer_pool_size=1Ginnodb_log_buffer_size=32Minnodb_log_file_size=128Minnodb_flush_method=O_DIRECT######################thread_concurrency=32long_query_time=2slow-query-log=onslow-query-log-file=/usr/local/mysql/log/mysql_slow.log[mysqldump]quickmax_allowed_packet=32M[mysqld_safe]log-error=/var/log/mysqld.logpid-file=/var/run/mysqld/mysqld.pid 配置mysql服务 123cp support-files/mysql.server /etc/init.d/mysqldchkconfig --add mysqld # 添加到系统服务chkconfig mysqld on # 开机启动 接下来我们就可以使用systemctl start mysqld启动服务了，但是每个人安装不一样，总会有不同的报错，这个时候看下tail -f /var/log/mysqld.log看下对应报啥错，有时候大多是忘记设计权限了 12345systemctl restart mysqld -- 重启mysqlsystemctl stop mysqld -- 停止mysql服务systemctl status mysqld -- 查看mysql服务状态systemctl daemon-reload -- 如果重新设置了服务，可以使用这个重载一下 配置一下可以直接使用mysql的命令吧 1234vim /etc/profileexport PATH=$PATH:/usr/local/mysql/binsource /etc/profile 接下来就是更改密码了 因为我们配置了skip-grant-tables,所以第一次认证，直接使用这样的 12mysql -uroot -p回车 设置新密码 1234use mysql;update user set authentication_string=password(&#x27;新密码&#x27;) where user=&#x27;root&#x27;; flush privileges; 注意把skip-grant-tables注释掉，重新启动mysql服务 重新编译记得清下编译的时候的缓存文件 123cd /data/soft/mysqlrm -f CMakeCache.txtmake clean mysql安装完毕，接下来查看下mysql进程 1ps -aux | grep mysql 一些报错产生的原因，可以参考这个博客，报错原因","categories":[],"tags":[{"name":"mysql","slug":"mysql","permalink":"http://example.com/tags/mysql/"}]}],"categories":[],"tags":[{"name":"skynet","slug":"skynet","permalink":"http://example.com/tags/skynet/"},{"name":"game-dev","slug":"game-dev","permalink":"http://example.com/tags/game-dev/"},{"name":"mysql","slug":"mysql","permalink":"http://example.com/tags/mysql/"}]}